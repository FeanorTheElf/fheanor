use feanor_math::divisibility::DivisibilityRing;
use feanor_math::integer::IntegerRing;
use feanor_math::ring::*;
use feanor_math::rings::extension::FreeAlgebra;
use feanor_math::rings::float_complex::Complex64;
use feanor_math::rings::poly::PolyRing;
use feanor_math::rings::zn::zn_64::{self, Zn, ZnEl};
use feanor_math::rings::zn::ZnRing;
use feanor_math::seq::{SwappableVectorViewMut, VectorView, VectorViewMut};

use crate::cyclotomic::{CyclotomicGaloisGroup, CyclotomicGaloisGroupEl, CyclotomicRing};
use crate::IsEq;

///
/// Trait for objects that represent number rings (more concretely, orders in number
/// fields), endowed with certain information that is necessary to perform HE-related
/// operations efficiently.
///  - The number ring should have a fixed "small basis", which consists of elements that
///    have small canonical norm. This basis will be used for operations that care about
///    "smallness" and noise growth.
///  - The object should also provide functionality to search for primes `p` modulo which
///    `R/p` is isomorphic to `Fp^n`, and thus `R/p` has the "mult basis" corresponding
///    to the unit vectors on the right hand side of `R/p ~ Fp^n`. This basis has the nice
///    property that it allows computing multiplications component-wise, however note that it
///    is not fixed but depends on `p`.
///  - Finally, we also want the order to be generated by a single element `a`, which gives rise
///    to the "coeff basis", given by `1, a, a^2, ..., a^(n - 1)`.
/// 
/// Two [`HENumberRing`]s that are considered equal as given by [`PartialEq`] should
/// represent the same ring, and also all three basis should coincide (in case of the "mult basis",
/// it should coincide for every prime `p`).
/// 
pub trait HENumberRing: Send + Sync + PartialEq {

    type Decomposed: HENumberRingMod;

    fn mod_p(&self, Fp: zn_64::Zn) -> Self::Decomposed;

    ///
    /// Returns the largest prime `<= leq_than` that is "suitable" for this
    /// number ring. TODO: refactor to get rid of this fuzzy notion of suitable.
    /// 
    /// Originally, "suitable" was supposed to mean that `p` splits completely
    /// in the number ring, but since then a lot of additional constraints have been
    /// introduced, so that now it means "works well with the single-RNS and double-RNS
    /// implementation".
    /// 
    fn largest_suitable_prime(&self, leq_than: i64) -> Option<i64>;

    ///
    /// Returns an upper bound on the value
    /// ```text
    ///   sup_(x in R \ {0}) | x |_can / | x |_inf
    /// ```
    /// 
    /// Note that while the canonical norm `|.|_can` depends only on the
    /// number ring `R`, the infinity norm refers to the infinity norm
    /// when written w.r.t. the "small basis".
    /// 
    fn inf_to_can_norm_expansion_factor(&self) -> f64;

    ///
    /// Returns an upper bound on the value
    /// ```text
    ///   sup_(x in R \ {0}) | x |_inf / | x |_can
    /// ```
    /// 
    /// Note that while the canonical norm `|.|_can` depends only on the
    /// number ring `R`, the infinity norm refers to the infinity norm
    /// when written w.r.t. the "small basis".
    /// 
    fn can_to_inf_norm_expansion_factor(&self) -> f64;

    ///
    /// Returns an upper bound on the value
    /// ```text
    ///   sup_(x, y in R \ {0}) | xy |_inf / (| x |_inf | y |_inf)
    /// ```
    /// 
    fn product_expansion_factor(&self) -> f64 {
        self.inf_to_can_norm_expansion_factor().powi(2) * self.can_to_inf_norm_expansion_factor()
    }

    fn generating_poly<P>(&self, poly_ring: P) -> El<P>
        where P: RingStore,
            P::Type: PolyRing + DivisibilityRing,
            <<P::Type as RingExtension>::BaseRing as RingStore>::Type: IntegerRing;

    fn rank(&self) -> usize;
}

pub trait HECyclotomicNumberRing: HENumberRing {    

    type DecomposedAsCyclotomic: HECyclotomicNumberRingMod + IsEq<Self::Decomposed>;

    fn n(&self) -> u64;

    fn galois_group(&self) -> CyclotomicGaloisGroup {
        CyclotomicGaloisGroup::new(self.n())
    }
}

///
/// A [`DecomposableNumberRing`] `R` modulo a prime `p` that splits completely in `R`.
/// 
/// This object may define up to three different basis of `R / p`, with the following
/// properties:
///  - the "small basis" should consist of elements whose shortest lift to `R` has small
///    canonical norm
///  - the "mult basis" should allow for component-wise multiplication, i.e. `bi * bi = bi`
///    and `bi * bj = 0` for `i != j`
///  - the "coeff basis" should consist of powers of a generator of the ring, which for
///    cyclotomic rings should be the root of unity.
/// Both "small basis" and "coeff basis" should be the reduction of a corresponding
/// canonical basis of `R`.
/// 
/// Note that it is valid for any of these basis to coincide, and then implement the 
/// corresponding conversions as no-ops.
/// 
/// This design is motivated by the example of `Z[ùùµ_n]` for a composite `n`, since in
/// this case, we need three different basis.
///  - The "small basis" is the powerful basis `ùùµ^(n/n1 * i1 + ... + n/nr * ir)` with
///    `0 <= ij < phi(nj)`, where `nj` runs through pairwise coprime factors of `n`
///  - The "mult basis" is the preimage of the unit vector basis under `Fp[ùùµ] -> Fp^phi(n)`
///  - The "coeff basis" is the basis `1, ùùµ, ùùµ^2, ..., ùùµ^phi(n)`
/// While one could choose "small basis" and "coeff basis" to be equal (after all, the
/// elements `ùùµ^i` are all "small"), staying in "small basis" whenever possible has
/// performance benefits, because of the tensor-decomposition.
/// 
pub trait HENumberRingMod: Send + Sync + PartialEq {

    fn base_ring(&self) -> &zn_64::Zn;

    fn rank(&self) -> usize;

    fn small_basis_to_mult_basis<V>(&self, data: V)
        where V: SwappableVectorViewMut<zn_64::ZnEl>;

    fn mult_basis_to_small_basis<V>(&self, data: V)
        where V: SwappableVectorViewMut<zn_64::ZnEl>;

    fn coeff_basis_to_small_basis<V>(&self, data: V)
        where V: SwappableVectorViewMut<zn_64::ZnEl>;

    fn small_basis_to_coeff_basis<V>(&self, data: V)
        where V: SwappableVectorViewMut<zn_64::ZnEl>;
}

pub trait HECyclotomicNumberRingMod: HENumberRingMod {

    fn n(&self) -> u64;

    fn galois_group(&self) -> CyclotomicGaloisGroup {
        CyclotomicGaloisGroup::new(self.n())
    }

    ///
    /// Permutes the components of an element w.r.t. the mult basis to
    /// obtain its image under the given Galois action.
    /// 
    fn permute_galois_action<V1, V2>(&self, src: V1, dst: V2, galois_element: CyclotomicGaloisGroupEl)
        where V1: VectorView<zn_64::ZnEl>,
            V2: SwappableVectorViewMut<zn_64::ZnEl>;
}